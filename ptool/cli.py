import os
import uuid
import click
import pathlib
from pprint import pprint


disclaimer = """

################################################################################
# DISCLAIMER: USE AT YOUR OWN RISK
# By executing this script generated by ptool, you acknowledge and accept that
# you are solely responsible for its consequences. Review and understand each
# command before execution. Make backups if you consider it necessary.
# The developers of ptool are not liable for any issues resulting from its use.
################################################################################

"""


@click.group()
def cli():
    pass


@cli.command()
@click.option(
    "-o", "--outfile", type=click.File("w"), default="-", help="file to write results"
)
@click.option(
    "--fullpath",
    is_flag=True,
    required=False,
    help="displays full path instead of relative path",
)
@click.option("--ignore", help="ignores directory and files")
@click.option(
    "-t",
    "--threshold",
    default=0.1,
    show_default=True,
    help="minumin value to satisfy valid association",
)
@click.argument("left", required=True, type=click.Path())
@click.argument("right", required=True, type=click.Path())
def compare(outfile, fullpath, ignore, threshold, left, right):
    """Compare csv files containing checksum to infer the status of data
    in these data pools. The results include, synced files at both HPC sites. unsynced files.
    directory mapping of synced files. filename mis-matches.

    LEFT: csv file containing checksums of all files in the pool for a given project and HPC site.

    RIGHT: similar file as LEFT but from different HPC site for the same project.
    """
    from .analyse import read_csv, compare_compact

    ld, ld_dups = read_csv(left, ignore=ignore)
    lr, lr_dups = read_csv(right, ignore=ignore)
    columns = "rpath"
    if fullpath:
        columns = "fpath"
    res = compare_compact(ld, lr, columns=columns, threshold=threshold, relabel=False)
    if "stdout" in outfile.name:
        click.echo(res)
    else:
        click.echo(f"Writing results as csv to file {outfile.name}")
        res.to_csv(outfile)
        click.echo(res)


@cli.command()
@click.option("--ignore", help="ignores directory and files")
@click.option(
    "--drop-duplicates",
    is_flag=True,
    show_default=True,
    default=False,
    help="drops duplicated (identical) entries in 'left' argument",
)
@click.option(
    "--compact",
    is_flag=True,
    show_default=True,
    default=False,
    help="shortern table by ignoring `unique` only association",
)
@click.option(
    "-t",
    "--threshold",
    default=0.1,
    show_default=True,
    help="minumin value to satisfy valid association",
)
@click.argument("left", required=True, type=click.Path())
@click.argument("right", required=True, type=click.Path())
def summary(ignore, drop_duplicates, compact, threshold, left, right):
    """Prints a short summary by analysing csv files.

    LEFT: csv file containing checksums of all files in the pool for a given project and HPC site.

    RIGHT: similar file as LEFT but from different HPC site for the same project.
    """
    from .analyse import summary

    summary(
        left,
        right,
        ignore=ignore,
        compact=compact,
        drop_duplicates=drop_duplicates,
        threshold=threshold,
    )


def sanitise(host, path):
    "sanitise the hostpart of the path"
    if (not host) or ("awi.de" in host):
        return path
    return f"{host}:{path}"


@cli.command()
@click.option("--ignore", help="ignores directory and files")
@click.option(
    "--flags",
    "Flag",
    type=click.Choice(["unique", "modified", "both"]),
    default="both",
    help="association type to include",
)
@click.option(
    "-t",
    "--threshold",
    default=0.1,
    show_default=True,
    help="minumin value to satisfy valid association",
)
@click.option(
    "-l",
    "--lefthost",
    default="",
    help="username@host prefix to the path for left file",
)
@click.option(
    "-r",
    "--righthost",
    default="",
    help="username@host prefix to the path for right file",
)
@click.argument("left", required=True, type=click.Path())
@click.argument("right", required=True, type=click.Path())
def prepare_rsync(ignore, Flag, threshold, lefthost, righthost, left, right):
    """Prepares rsync commands for the transfer.

    Denpending on where data needs to pushed or pulled, provide
    either `--lefthost` or `--righthost` information to prefix that path.

    Note: when Albedo system is invloved, run this command on Albedo and
    provide the other host information as Albedo can not be reached from
    other machines.

    Examples that WORK:

    # commands executed on Albedo (i.e., we are on Albedo)

    1. sync data: Levante -> Albedo

       ptool prepare-rsync --lefthost user@levante.dkrz.de checksum_levante_fesom2.csv checksum_albedo_fesom2.csv

    2. sync data: Albedo -> Levante

       ptool prepare-rsync --righthost user@levante.dkrz.de checksum_albedo_fesom2.csv checksum_levante_fesom2.csv

    Examples that FAIL:

    # commands executed on Levante (i.e., we are on Levante)

    1. sync data: Levante -> Albedo

       ptool prepare-rsync --righthost user@albedo0.dmawi.de checksum_levante_fesom2.csv checksum_albedo_fesom2.csv

       will produce rsync commands as follows:

       rsync /some/path/on/levante user@albedo0.dmawi.de:/some/path/on/albedo

       Although syntactically correct command, it fails as Albedo is not reachable from other machines

    2. sync data: Albedo -> Levante

       ptool prepare-rsync --lefthost user@albedo0.dmawi.de checksum_albedo_fesom2.csv checksum_levante_fesom2.csv
    """
    if Flag == "both":
        Flag = {"unique", "modified_latest_left", "modified_latest_right"}
    elif Flag == "modified":
        Flag = {"modified_latest_left", "modified_latest_right"}
    else:
        Flag = {
            "unique",
        }

    from .analyse import read_csv, compare, compare_compact, directory_map, merge

    ld, ld_dups = read_csv(left, ignore=ignore)
    rd, rd_dups = read_csv(right, ignore=ignore)
    left_host = lefthost
    right_host = righthost
    dm = dict(directory_map(merge(ld, rd)).values)
    c = compare(ld, rd, threshold=threshold)
    fmap = {}
    syncs = ["#!/bin/bash"]
    syncs.append(disclaimer)
    prefix_left = c.prefix_left.dropna().iloc[0]
    prefix_right = c.prefix_right.dropna().iloc[0]
    for name, grp in c.groupby("rparent_left"):
        use_relative = True
        if name in dm:
            use_relative = False
        filelist = []
        # grp = grp.reset_index()
        # flags = set(grp.flag.unique())
        flags = set(grp.reset_index().flag.unique())
        common_flags = list(flags & Flag)
        grp = grp.loc[common_flags].reset_index()
        if use_relative:
            filelist.extend(list(grp.rpath_left))
        else:
            filelist.extend(list(grp.fname_left))
        if filelist:
            fid = str(uuid.uuid4())[:8]
            fmap[fid] = filelist
            if use_relative:
                sync = f"rsync -av --files-from=flist/{fid} {sanitise(left_host, prefix_left)} {sanitise(right_host, prefix_right)}"
            else:
                rparent_left = name
                rparent_right = dm[name]
                sync = f"rsync -av --files-from=flist/{fid} {sanitise(left_host, prefix_left)}{rparent_left}/ {sanitise(right_host, prefix_right)}{rparent_right}/"
            syncs.append(f"\n# {name}")
            syncs.append(sync)
    flist = ["# file list per directory\n"]
    flist.append(
        """
if [ ! -d flist ]; then
    mkdir flist
fi
"""
    )
    flist_add = flist.append
    for name, fnames in fmap.items():
        flist_add("\n")
        flist_add(f"cat > flist/{name} << EOF")
        flist.extend(fnames)
        flist_add("EOF")
    flist = "\n".join(flist)
    syncs.insert(2, flist)
    # cleanup
    # names = " ".join(fmap)
    syncs.append("\n#cleanup")
    syncs.append("rm -rf flist")
    # syncs.append(f"rm {names}")
    syncs = "\n".join(syncs)
    # os.makedirs("flist", exist_ok=True)
    with open("sync_cmd.sh", "w") as fid:
        fid.writelines(syncs)
    # for name, fnames in fmap.items():
    #    with open(f"flist/{name}", "w") as fid:
    #        fnames = "\n".join(fnames)
    #        fid.writelines(fnames)
    print("Created sync_cmd.sh")


@cli.command()
@click.option(
    "--drop-hidden-files/--no-drop-hidden-files",
    default=True,
    is_flag=True,
    show_default=True,
    help="ignore hidden files",
)
@click.option("--ignore", default=None, show_default=True, help="ignore dirs or files")
@click.option(
    "-o", "--outfile", type=click.File("w"), default="-", help="output filename"
)
@click.argument("path")
def checksums(path, outfile, ignore, drop_hidden_files):
    """Calculates imohash checksum of file(s) at the given path.
    Results are presented as csv.
    """
    from . import checksums

    path = os.path.expanduser(path)
    checksums.main(path, outfile, ignore, drop_hidden_files)


if __name__ == "__main__":
    cli()
